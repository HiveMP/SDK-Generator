import * as swagger from 'swagger2';
import * as schema from 'swagger2/src/schema';
import * as fs from 'fs';
import * as path from 'path';
import { TargetGenerator } from './TargetGenerator';

export class CSharp35Generator implements TargetGenerator {
  get name(): string {
    return 'CSharp-3.5';
  }

  async generate(documents: {[id: string]: swagger.Document}, outputDir: string): Promise<void> {

  }
}

export class CSharp45Generator implements TargetGenerator {
  get name(): string {
    return 'CSharp-4.5';
  }
  
  static stripDefinition(s: string): string {
    if (s.startsWith('#/definitions/')) {
      return s.substr('#/definitions/'.length);
    }
    return s;
  }

  static getCSharpTypeFromDefinition(namespace: string, definition: schema.Definition, useConst: boolean, useConstIn?: boolean): string {
    const constName = useConst ? 'const ' : '';
    const arrayConstName = useConstIn ? 'const ': '';
    const arrayConstSuffix = useConstIn ? '&' : '';
    let type = null;
    try {
      if (definition.type != null) {
        switch (definition.type as string|null) {
          case 'string':
            switch (definition.format) {
              case 'byte':
                type = 'byte[]';
                break;
              default:
                type = 'string';
                break;
            }
            break;
          case 'integer':
            switch (definition.format) {
              case 'int32':
                type = 'int';
                break;
              case 'int64':
                type = 'long';
                break;
            }
            break;
          case 'number':
            switch (definition.format) {
              case 'float':
                type = 'float';
                break;
              case 'double':
                type = 'double';
                break;
            }
            break;
          case 'boolean':
            type = 'bool';
            break;
          case 'object':
            type = 'string /* JSON STRING */';
            break;
          case 'array':
            type = 
              CSharp45Generator.getCSharpTypeFromDefinition(namespace, definition.items, false, useConstIn) +
              '[]';
            break;
        }
      } else if (definition.schema != null) {
        if (definition.schema.type == 'array') {
          type = 
            CSharp45Generator.getCSharpTypeFromDefinition(namespace, definition.schema.items, false, useConstIn) +
            '[]';
        } else if (definition.schema.$ref != null) {
          type = namespace + '.' + CSharp45Generator.stripDefinition(definition.schema.$ref);
        } else {
          return CSharp45Generator.getCSharpTypeFromDefinition(namespace, definition.schema, useConst, useConstIn);
        }
      } else if (definition.$ref != null) {
        type = namespace + '.' + CSharp45Generator.stripDefinition(definition.$ref);
      }
    } catch (ex) {
      console.warn(ex);
      type = 'int /* unknown */';
    }
    return type;
  }

  async generate(documents: {[id: string]: swagger.Document}, outputDir: string): Promise<void> {
    let code = `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

#if UNITY_5 || UNITY_5_3_OR_NEWER
#define IS_UNITY
#endif
#if !(NET35 || (IS_UNITY && NET_2_0 && NET_2_0_SUBSET))
#define HAS_TASKS
#define HAS_HTTPCLIENT
#endif

`;

    for (let apiId in documents) {
      let api = documents[apiId];
      let csharpName = api.info["x-sdk-csharp-package-name"];
      let namespace = csharpName + '.Api';

      code += `
namespace ${namespace}
{
    #pragma warning disable // Disable all warnings
`;

      let tags = {};
      for (let pathName in api.paths) {
        for (let methodName in api.paths[pathName]) {
          let tag = api.paths[pathName][methodName].tags[0];
          if (tags[tag] == undefined) {
            tags[tag] = [];
          }
          tags[tag].push({
            pathName: pathName,
            methodName: methodName
          });
        }
      }

      for (let tag in tags) {
        code += `
    [System.CodeDom.Compiler.GeneratedCode("HiveMP SDK Generator", "1.0.0.0")]
    public interface I${tag}Client
    {
`;

        for (let el of tags[tag]) {
          let methodValue = api.paths[el.pathName][el.methodName];
          let methodName = 
            methodValue.operationId[0].toUpperCase() +
            methodValue.operationId.substr(1);
          let returnValue = 'void';
          let asyncReturnValue = 'System.Threading.Tasks.Task';
          if (methodValue.responses != null && methodValue.responses["200"] != null) {
            returnValue = CSharp45Generator.getCSharpTypeFromDefinition(namespace, methodValue.responses["200"], false);
            if (returnValue == null) {
              returnValue = 'void';
            } else {
              asyncReturnValue = 'System.Threading.Tasks.Task<' + returnValue + '>';
            }
          }
          code += `
#if HAS_TASKS
          ${asyncReturnValue} ${methodName}Async()
          {
              throw new System.NotImplementedException();
          }
#endif
          ${returnValue} ${methodName}()
          {
              throw new System.NotImplementedException();
          }
`;
        }

        code += `
    }
`;
      }

      code += `
}
`;
    }
    
    await new Promise((resolve, reject) => {
      fs.writeFile(path.join(outputDir, 'HiveMP.cs'), code, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}