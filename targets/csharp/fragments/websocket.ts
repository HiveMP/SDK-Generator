export function getWebSocketClass(defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Net.WebSockets;
using System.Threading.Tasks;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace HiveMP.Api
{
    /// <summary>
    /// Base class that handles implementing WebSocket communications with HiveMP.
    /// You should not use this in your own code; it's surface area may change between
    /// SDK versions.
    /// </summary>
    public abstract class HiveMPWebSocket
    {
        protected readonly ClientWebSocket _webSocket;
        private CancellationToken _cancellationToken;
        private Task _listeningTask;
        private bool _hasStartedReceivingMessages;

        public HiveMPWebSocket(ClientWebSocket webSocket)
        {
            _webSocket = webSocket;
            _cancellationToken = new CancellationToken(false);
        }

        protected void StartRaisingEvents()
        {
            _listeningTask = Task.Run(ListenForMessagesAndRaiseEvents);
            _hasStartedReceivingMessages = true;
        }

        protected async Task WaitForDisconnect(CancellationToken cancellationToken)
        {
            if (!_hasStartedReceivingMessages)
            {
                StartRaisingEvents();
            }
            
            _cancellationToken = cancellationToken;
            await _listeningTask;
        }

        protected abstract Task HandleMessage(string protocolId, JToken value, CancellationToken cancellationToken);

        private async Task ListenForMessagesAndRaiseEvents()
        {
            var buffer = WebSocket.CreateServerBuffer(4096);
            var resultBuilder = new StringBuilder();
            while ((_webSocket.State == WebSocketState.Connecting ||
                _webSocket.State == WebSocketState.Open) &&
                !_cancellationToken.IsCancellationRequested)
            {
                var result = await _webSocket.ReceiveAsync(buffer, _cancellationToken);

                if (result.MessageType == WebSocketMessageType.Text)
                {
                    resultBuilder.Append(Encoding.UTF8.GetString(buffer.Array, 0, result.Count));
                }
                else
                {
                    // We don't handle binary messages.
                }

                if (result.EndOfMessage)
                {
                    var jsonRequest = resultBuilder.ToString();
                    var jsonObject = JsonConvert.DeserializeObject<JObject>(jsonRequest);

                    var requestType = jsonObject.Property("type").Value<string>();
                    var requestObject = jsonObject.Property("value").Value<JToken>();

                    try
                    {
                        HandleMessage(requestType, requestObject, _cancellationToken);
                    }
                    catch
                    {
                        // TODO: Provide an interface for propagating exceptions here.
                    }
                }

                if (result.CloseStatus != null)
                {
                    break;
                }
            }
        }
    }
}

`;
}