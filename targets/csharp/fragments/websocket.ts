export function getWebSocketClass(genericNamespace: string, defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
#if HAS_TASKS
using System.Net.WebSockets;
using System.Threading.Tasks;
#else
using WebSocket4Net;
#endif
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace ${genericNamespace}
{
    /// <summary>
    /// Base class that handles implementing WebSocket communications with HiveMP.
    /// You should not use this in your own code; it's surface area may change between
    /// SDK versions.
    /// </summary>
    public abstract class HiveMPWebSocket
    {
#if HAS_TASKS
        protected readonly ClientWebSocket _webSocket;
        private CancellationToken _cancellationToken;
        private Task _listeningTask;
#else
        protected readonly WebSocket _webSocket;
        private ${genericNamespace}.HiveMPPromise _listeningPromise;
#endif
        private bool _hasStartedReceivingMessages;

#if HAS_TASKS
        public HiveMPWebSocket(ClientWebSocket webSocket)
        {
            _webSocket = webSocket;
            _cancellationToken = new CancellationToken(false);
        }

        protected void StartRaisingEvents(CancellationToken cancellationToken)
        {
            _cancellationToken = cancellationToken;
            _listeningTask = Task.Run(ListenForMessagesAndRaiseEvents);
            _hasStartedReceivingMessages = true;
        }

        protected async Task WaitForDisconnect(CancellationToken cancellationToken)
        {
            if (!_hasStartedReceivingMessages)
            {
                StartRaisingEvents(cancellationToken);
            }
            else if (cancellationToken != CancellationToken.None)
            {
                throw new InvalidOperationException("cancellationToken must be CancellationToken.None when calling WaitForDisconnect if StartRaisingEvents has already been called");
            }

            await _listeningTask;
        }

        protected abstract Task HandleMessage(string protocolId, JToken value, CancellationToken cancellationToken);
        
        private async Task ListenForMessagesAndRaiseEvents()
        {
            try
            {
                var buffer = WebSocket.CreateServerBuffer(4096);
                while ((_webSocket.State == WebSocketState.Connecting ||
                    _webSocket.State == WebSocketState.Open) &&
                    !_cancellationToken.IsCancellationRequested)
                {
                    try
                    {
                        var result = await _webSocket.ReceiveAsync(buffer, _cancellationToken);
                        var resultBuilder = new StringBuilder();

                        if (result.MessageType == WebSocketMessageType.Text)
                        {
                            resultBuilder.Append(Encoding.UTF8.GetString(buffer.Array, 0, result.Count));
                        }
                        else
                        {
                            // We don't handle binary messages.
                        }

                        if (result.EndOfMessage && result.MessageType == WebSocketMessageType.Text)
                        {
                            var jsonRequest = resultBuilder.ToString();
                            var jsonObject = JsonConvert.DeserializeObject<JObject>(jsonRequest);

                            var requestType = jsonObject.Property("type").Value.ToObject<string>();
                            var requestObject = jsonObject.Property("value").Value.ToObject<JToken>();

                            try
                            {
                                await HandleMessage(requestType, requestObject, _cancellationToken);
                            }
                            catch
                            {
                                // TODO: Provide an interface for propagating exceptions here.
                            }
                        }

                        if (result.CloseStatus != null)
                        {
                            break;
                        }
                    }
                    catch (TaskCanceledException) when ((_webSocket.State != WebSocketState.Connecting &&
                      _webSocket.State != WebSocketState.Open) ||
                      _cancellationToken.IsCancellationRequested)
                    {
                        // Normal shutdown.

                        // TODO: Some websocket non-open states are error states, and we should maybe think
                        // about propagating them in the SDK. However, from HiveMP's perspective there is
                        // no semantic difference between the server closing the connection normally
                        // or returning an error value, as the API never uses WebSocket error states to
                        // communicate differentiating information to the client. In all cases of disconnection,
                        // if the client wanted to remain connected, they just need to connect again.

                        break;
                    }
                    catch (OperationCanceledException) when ((_webSocket.State != WebSocketState.Connecting &&
                      _webSocket.State != WebSocketState.Open) ||
                      _cancellationToken.IsCancellationRequested)
                    {
                        // Normal shutdown.

                        // TODO: Some websocket non-open states are error states, and we should maybe think
                        // about propagating them in the SDK. However, from HiveMP's perspective there is
                        // no semantic difference between the server closing the connection normally
                        // or returning an error value, as the API never uses WebSocket error states to
                        // communicate differentiating information to the client. In all cases of disconnection,
                        // if the client wanted to remain connected, they just need to connect again.

                        break;
                    }
                }

                if (_webSocket.State == WebSocketState.Connecting ||
                    _webSocket.State == WebSocketState.Open)
                {
                    await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "The client terminated the connection due to token cancellation", CancellationToken.None);
                }
            }
            finally
            {
                _webSocket.Dispose();
            }
        }
#else
        public HiveMPWebSocket(WebSocket webSocket)
        {
            _webSocket = webSocket;
        }

        protected void StartRaisingEvents()
        {
            _listeningPromise = new ${genericNamespace}.HiveMPPromise(ListenForMessagesAndRaiseEvents);
            ${genericNamespace}.HiveMPPromiseScheduler.Execute(_listeningPromise);
            _hasStartedReceivingMessages = true;
        }

        protected ${genericNamespace}.HiveMPPromise WaitForDisconnect()
        {
            if (!_hasStartedReceivingMessages)
            {
                StartRaisingEvents();
            }

            return _listeningPromise;
        }

        protected abstract void HandleMessage(string protocolId, JToken value);

        private void ListenForMessagesAndRaiseEvents(Action resolve, Action<Exception> reject)
        {
            try
            {
                EventHandler<MessageReceivedEventArgs> receiveHandler = null;
                EventHandler closedHandler = null;
                receiveHandler = (sender, e) =>
                {
                    var jsonRequest = e.Message;
                    var jsonObject = JsonConvert.DeserializeObject<JObject>(jsonRequest);

                    var requestType = jsonObject.Property("type").Value.ToObject<string>();
                    var requestObject = jsonObject.Property("value").Value.ToObject<JToken>();

                    ${genericNamespace}.HiveMPPromiseScheduler.ExecuteWithMainThreadCallbacks(
                        new ${genericNamespace}.HiveMPPromise((resolve_, reject_) => { resolve_(); })
                            .Then(() =>
                                {
                                    HandleMessage(requestType, requestObject);
                                })
                    );
                };
                closedHandler = (sender, e) =>
                {
                    _webSocket.MessageReceived -= receiveHandler;
                    _webSocket.Closed -= closedHandler;
                    resolve();
                };
                _webSocket.MessageReceived += receiveHandler;
                _webSocket.Closed += closedHandler;
                _webSocket.Open();

                while (_webSocket.State != WebSocketState.Closed)
                {
                    Thread.Sleep(1000);
                }
            }
            catch (Exception ex)
            {
                reject(ex);
            }
            finally
            {
                _webSocket.Dispose();
            }
        }
#endif

    }
}
`;
}