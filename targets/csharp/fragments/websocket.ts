export function getWebSocketClass(defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Net.WebSockets;
using System.Threading.Tasks;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace HiveMP.Api
{
    /// <summary>
    /// Base class that handles implementing WebSocket communications with HiveMP.
    /// You should not use this in your own code; it's surface area may change between
    /// SDK versions.
    /// </summary>
    public abstract class HiveMPWebSocket
    {
        protected readonly ClientWebSocket _webSocket;
        private CancellationToken _cancellationToken;
        private Task _listeningTask;
        private bool _hasStartedReceivingMessages;

        public HiveMPWebSocket(ClientWebSocket webSocket)
        {
            _webSocket = webSocket;
            _cancellationToken = new CancellationToken(false);
        }

        protected void StartRaisingEvents()
        {
            _listeningTask = Task.Run(ListenForMessagesAndRaiseEvents);
            _hasStartedReceivingMessages = true;
        }

        protected async Task WaitForDisconnect(CancellationToken cancellationToken)
        {
            if (!_hasStartedReceivingMessages)
            {
                StartRaisingEvents();
            }
            
            _cancellationToken = cancellationToken;
            await _listeningTask;
        }

        protected abstract Task HandleMessage(string protocolId, JToken value, CancellationToken cancellationToken);

        private async Task ListenForMessagesAndRaiseEvents()
        {
            try
            {
                var buffer = WebSocket.CreateServerBuffer(4096);
                var resultBuilder = new StringBuilder();
                while ((_webSocket.State == WebSocketState.Connecting ||
                    _webSocket.State == WebSocketState.Open) &&
                    !_cancellationToken.IsCancellationRequested)
                {
                    try
                    {
                        var result = await _webSocket.ReceiveAsync(buffer, _cancellationToken);

                        if (result.MessageType == WebSocketMessageType.Text)
                        {
                            resultBuilder.Append(Encoding.UTF8.GetString(buffer.Array, 0, result.Count));
                        }
                        else
                        {
                            // We don't handle binary messages.
                        }

                        if (result.EndOfMessage)
                        {
                            var jsonRequest = resultBuilder.ToString();
                            var jsonObject = JsonConvert.DeserializeObject<JObject>(jsonRequest);

                            var requestType = jsonObject.Property("type").Value<string>();
                            var requestObject = jsonObject.Property("value").Value<JToken>();

                            try
                            {
                                await HandleMessage(requestType, requestObject, _cancellationToken);
                            }
                            catch
                            {
                                // TODO: Provide an interface for propagating exceptions here.
                            }
                        }

                        if (result.CloseStatus != null)
                        {
                            break;
                        }
                    }
                    catch (TaskCanceledException) when ((_webSocket.State != WebSocketState.Connecting &&
                      _webSocket.State != WebSocketState.Open) ||
                      _cancellationToken.IsCancellationRequested)
                    {
                        // Normal shutdown.

                        // TODO: Some websocket non-open states are error states, and we should maybe think
                        // about propagating them in the SDK. However, from HiveMP's perspective there is
                        // no semantic difference between the server closing the connection normally
                        // or returning an error value, as the API never uses WebSocket error states to
                        // communicate differentiating information to the client. In all cases of disconnection,
                        // if the client wanted to remain connected, they just need to connect again.

                        break;
                    }
                    catch (OperationCanceledException) when ((_webSocket.State != WebSocketState.Connecting &&
                      _webSocket.State != WebSocketState.Open) ||
                      _cancellationToken.IsCancellationRequested)
                    {
                        // Normal shutdown.

                        // TODO: Some websocket non-open states are error states, and we should maybe think
                        // about propagating them in the SDK. However, from HiveMP's perspective there is
                        // no semantic difference between the server closing the connection normally
                        // or returning an error value, as the API never uses WebSocket error states to
                        // communicate differentiating information to the client. In all cases of disconnection,
                        // if the client wanted to remain connected, they just need to connect again.

                        break;
                    }
                }

                if (_webSocket.State == WebSocketState.Connecting ||
                    _webSocket.State == WebSocketState.Open)
                {
                    await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "The client terminated the connection due to token cancellation", CancellationToken.None);
                }
            }
            finally
            {
                _webSocket.Dispose();
            }
        }
    }
}

`;
}