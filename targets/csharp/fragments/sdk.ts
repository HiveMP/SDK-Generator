export function getSdkSetup(defines: string[]) {
  const clientConnectPlatforms = [
    'Win32',
    'Win64',
    'Mac64',
    'Linux32',
    'Linux64'
  ];

  let code = `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

namespace HiveMP.Api
{
    public static class HiveMPSDKSetup
    {
        private static IClientConnect _clientConnect;
        private static byte[] _clientConnectCustomInit = null;
        private static string _clientConnectEndpoint = "https://client-connect-api.hivemp.com/v1";
        private static bool _didInit;
        private static object _initLock = new object();
        private static System.Threading.ManualResetEvent _clientConnectEvent = new System.Threading.ManualResetEvent(false);

#if ENABLE_CLIENT_CONNECT_SDK
#if HAS_TASKS
        [System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions]
#endif
        private static void SetupClientConnect()
        {
#if IS_UNITY
            // Unity handles the mapping of native DLLs in it's .meta files.
            _clientConnect = new ClientConnectUnityPlatform();
#elif NET35
            if (System.IO.Path.DirectorySeparatorChar == '\\\\')
            {
                // Windows
                if (System.IntPtr.Size == 8)
                {
                    // 64-bit
                    _clientConnect = new ClientConnectWin64Platform();
                }
                else
                {
                    // 32-bit
                    _clientConnect = new ClientConnectWin32Platform(); 
                }
            }
            else
            {
                if (System.IO.Directory.Exists("/Library"))
                {
                    // macOS
                    if (System.IntPtr.Size == 8)
                    {
                        // 64-bit
                        _clientConnect = new ClientConnectMac64Platform();
                    }
                    else
                    {
                        // 32-bit macOS is not supported.  32-bit support for
                        // macOS is being removed by Apple in the near future.
                    }
                }
                else
                {
                    // Linux
                    if (System.IntPtr.Size == 8)
                    {
                        // 64-bit
                        _clientConnect = new ClientConnectLinux64Platform();
                    }
                    else
                    {
                        // 32-bit
                        _clientConnect = new ClientConnectLinux32Platform();
                    }
                }
            }
#else
            if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows))
            {
                // Windows
                if (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture == System.Runtime.InteropServices.Architecture.X64)
                {
                    // 64-bit
                    _clientConnect = new ClientConnectWin64Platform();
                }
                else if (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture == System.Runtime.InteropServices.Architecture.X86)
                {
                    // 32-bit
                    _clientConnect = new ClientConnectWin32Platform(); 
                }
                else
                {
                    // Other unsupported (like ARM/ARM64)
                    _clientConnect = null;
                }
            }
            else if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.OSX))
            {
                if (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture == System.Runtime.InteropServices.Architecture.X64)
                {
                    // 64-bit
                    _clientConnect = new ClientConnectMac64Platform();
                }
                else
                {
                    // Other unsupported (like ARM/ARM64)
                    // 32-bit macOS is not supported.  32-bit support for
                    // macOS is being removed by Apple in the near future.
                    _clientConnect = null;
                }
            }
            else if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Linux))
            {
                // Linux
                if (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture == System.Runtime.InteropServices.Architecture.X64)
                {
                    // 64-bit
                    _clientConnect = new ClientConnectLinux64Platform();
                }
                else if (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture == System.Runtime.InteropServices.Architecture.X86)
                {
                    // 32-bit
                    _clientConnect = new ClientConnectLinux32Platform();
                }
                else
                {
                    // Other unsupported (like ARM/ARM64)
                    _clientConnect = null;
                }
            }
            else
            {
                // Unsupported platform
                _clientConnect = null;
            }
#endif

            if (_clientConnect != null)
            {
                try
                {
                    _clientConnect.MapChunk("_startupTest.lua", System.Text.Encoding.ASCII.GetBytes(@"
function _startupTest_hotpatch(id, endpoint, api_key, parameters_json)
    return 403, ""Nope""
end
register_hotpatch(""no-api:testPUT"", ""_startupTest_hotpatch"")"));
                    _clientConnect.SetStartup("_startupTest.lua");
                    int statusCode;
                    var response = _clientConnect.CallHotpatch("no-api", "testPUT", "https://no-api.hivemp.nonexistent.com/v1", "", "{}", out statusCode);
                    if (response != "Nope")
                    {
                        // Something went wrong and we can't use Client Connect.
                        _clientConnect = null;
                    }
                }
                catch (System.Exception)
                {
                    // We can't use Client Connect
                    _clientConnect = null;
                }

                if (_clientConnect != null)
                {
                    // TODO: Wait on startup whenever we have to make an API call.
                    var t = new System.Threading.Thread(new System.Threading.ThreadStart(FinalizeClientConnectSetup));
                    t.IsBackground = true;
                    t.Start();
                }
            }

            if (_clientConnect == null)
            {
                _clientConnectEvent.Set();
            }
        }

        private static void FinalizeClientConnectSetup()
        {
            try
            {
                var filesClient = new HiveMP.ClientConnect.Api.FilesClient(string.Empty);
                var doInit = false;
                var cacheFolder = System.IO.Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.ApplicationData), "HiveMP");
                cacheFolder = System.IO.Path.Combine(cacheFolder, "ClientConnectAssets");
                try
                {
                    System.IO.Directory.CreateDirectory(cacheFolder);
                }
                catch
                {
                    // Cache may not be available, continue anyway.
                }
                var f = new HiveMP.ClientConnect.Api.FilesClient(string.Empty);
                f.BaseUrl = _clientConnectEndpoint;
                var files = f.FilesGET(new HiveMP.ClientConnect.Api.FilesGETRequest());
                foreach (var file in files)
                {
                    var filename = file.Key as string;
                    if (filename == null)
                    {
                        continue;
                    }

                    if (filename == "init.lua")
                    {
                        doInit = true;
                    }
                    
                    var fileCache = System.IO.Path.Combine(cacheFolder, file.Value.Sha1.ToLower());
                    if (System.IO.File.Exists(fileCache))
                    {
                        try
                        {
                            using (var stream = new System.IO.FileStream(fileCache, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read))
                            {
                                var data = new byte[stream.Length];
                                stream.Read(data, 0, data.Length);
                                _clientConnect.MapChunk(filename, data);
                                continue;
                            }
                        }
                        catch
                        {
                            // Fallback to download.
                        }
                    }

                    using (var client = new System.Net.WebClient())
                    {
                        client.Headers.Add("X-API-Key", string.Empty);
                        var data = client.DownloadData(file.Value.Url);
                        _clientConnect.MapChunk(filename, data);

                        try
                        {
                            if (!System.IO.File.Exists(fileCache))
                            {
                                using (var stream = new System.IO.FileStream(fileCache, System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.None))
                                {
                                    stream.Write(data, 0, data.Length);
                                    continue;
                                }
                            }
                        }
                        catch
                        {
                            // Failed to optionally cache, ignore.
                        }
                    }
                }
                if (_clientConnectCustomInit != null)
                {
                    if (doInit)
                    {
                        // Free existing chunk.
                        _clientConnect.FreeChunk("init.lua");
                    }

                    _clientConnect.MapChunk("init.lua", _clientConnectCustomInit);
                    doInit = true;
                }
                if (doInit)
                {
                    _clientConnect.SetStartup("init.lua");
                }
            }
            catch (System.Exception ex)
            {
#if IS_UNITY
                UnityEngine.Debug.LogError(ex);
#else
                // Client Connect failed to initialise.
#endif
            }

            _clientConnectEvent.Set();
        }

#if HAS_TASKS
        internal static System.Threading.Tasks.Task WaitForClientConnectAsync()
        {
            return AsTask(_clientConnectEvent);
        }

        private static System.Threading.Tasks.Task AsTask(System.Threading.WaitHandle handle)
        {
            var tcs = new System.Threading.Tasks.TaskCompletionSource<object>();
            var registration = System.Threading.ThreadPool.RegisterWaitForSingleObject(handle, (state, timedOut) =>
            {
                var localTcs = (System.Threading.Tasks.TaskCompletionSource<object>)state;
                if (timedOut)
                    localTcs.TrySetCanceled();
                else
                    localTcs.TrySetResult(null);
            }, tcs, System.Threading.Timeout.InfiniteTimeSpan, executeOnlyOnce: true);
            tcs.Task.ContinueWith((_, state) => ((System.Threading.RegisteredWaitHandle)state).Unregister(null), registration, System.Threading.Tasks.TaskScheduler.Default);
            return tcs.Task;
        }
#endif

        internal static void WaitForClientConnect()
        {
            _clientConnectEvent.WaitOne();
        }
#endif

#if IS_UNITY
        private static bool HiveMPCertificateValidation(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, X509Certificate2 nonSniRootCa)
        {
            // If there are no SSL errors, validation succeeds.
            if (sslPolicyErrors == SslPolicyErrors.None)
            {
                return true;
            }

            // If the sender is not a HTTPS Web Request, we can't validate whether the No SNI
            // certificate is for a HiveMP request.
            var httpWebRequest = sender as HttpWebRequest;
            if (httpWebRequest == null)
            {
                return false;
            }

            // If it's not a HiveMP request, we don't validate for it.
            if (!httpWebRequest.Address.Host.EndsWith(".hivemp.com"))
            {
                return false;
            }

            // First up, check if the chain has any statuses that are not related to CRL revocation.
            // We don't provide CRL lists for our No SNI certificate, because we're only using this
            // infrastructure to workaround Unity's poor SSL client support.
            if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) != 0)
            {
                var hasUnexpectedChainElementsValidationError = false;
                for (var i = 0; i < chain.ChainElements.Count; i++)
                {
                    var element = chain.ChainElements[i];
                    for (var s = 0; s < element.ChainElementStatus.Length; s++)
                    {
                        var chainStatus = element.ChainElementStatus[s];
                        if (chainStatus.Status != X509ChainStatusFlags.OfflineRevocation &&
                            chainStatus.Status != X509ChainStatusFlags.RevocationStatusUnknown)
                        {
                            hasUnexpectedChainElementsValidationError = true;
                        }
                    }
                }
                if (!hasUnexpectedChainElementsValidationError)
                {
                    sslPolicyErrors &= ~SslPolicyErrors.RemoteCertificateChainErrors;
                }
            }

            // If the remote name has a mismatch, check if the root CA for the provided
            // certificate is the Redpoint No SNI Root CA. We already know the request
            // is for *.hivemp.com due to previous checks.
            if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateNameMismatch) != 0)
            {
                var lastChainElement = chain.ChainElements[chain.ChainElements.Count - 1].Certificate;
                if (nonSniRootCa.Thumbprint == lastChainElement.Thumbprint)
                {
                    sslPolicyErrors &= ~SslPolicyErrors.RemoteCertificateNameMismatch;
                }
            }

            return sslPolicyErrors == SslPolicyErrors.None;
        }
#endif

        /// <summary>
        /// Sets custom init code to be used by the Client Connect SDK
        /// instead of the init.lua file provided by the API server.
        /// </summary>
        /// <remarks>
        /// There is no support for using this method.
        /// </remarks>
        public static void SetClientConnectCustomInit(byte[] init)
        {
            _clientConnectCustomInit = init;
        }

        /// <summary>
        /// Sets a custom endpoint for the Client Connect files retrieval
        /// that occurs during SDK startup.
        /// </summary>
        /// <remarks>
        /// There is no support for using this method.
        /// </remarks>
        public static void SetClientConnectEndpoint(string endpoint)
        {
            _clientConnectEndpoint = endpoint;
        }

        internal static bool IsHotpatched(string api, string operation)
        {
            if (_clientConnect == null)
            {
                return false; 
            }

            return _clientConnect.IsHotpatched(api, operation);
        }

        internal static string CallHotpatch(string api, string operation, string endpoint, string apiKey, string parametersAsJson, out int statusCode)
        {
            return _clientConnect.CallHotpatch(api, operation, endpoint, apiKey, parametersAsJson, out statusCode);
        }

        internal static void EnsureInited()
        {
            if (!_didInit)
            {
                lock (_initLock)
                {
#if IS_UNITY
                    var nonSniRootCa = new X509Certificate2(System.Convert.FromBase64String(@"
MIIGNjCCBB6gAwIBAgIJAIFAzu/SSMPWMA0GCSqGSIb3DQEBCwUAMIGnMQswCQYD
VQQGEwJBVTERMA8GA1UECAwIVmljdG9yaWExHzAdBgNVBAoMFlJlZHBvaW50IEdh
bWVzIFB0eSBMdGQxPDA6BgNVBAsMM1JlZHBvaW50IEdhbWVzIFB0eSBMdGQgTm8t
U05JIENlcnRpZmljYXRlIEF1dGhvcml0eTEmMCQGA1UEAwwdUmVkcG9pbnQgR2Ft
ZXMgTm8tU05JIFJvb3QgQ0EwHhcNMTgwMjE2MDQwNTE0WhcNMzgwMjExMDQwNTE0
WjCBpzELMAkGA1UEBhMCQVUxETAPBgNVBAgMCFZpY3RvcmlhMR8wHQYDVQQKDBZS
ZWRwb2ludCBHYW1lcyBQdHkgTHRkMTwwOgYDVQQLDDNSZWRwb2ludCBHYW1lcyBQ
dHkgTHRkIE5vLVNOSSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxJjAkBgNVBAMMHVJl
ZHBvaW50IEdhbWVzIE5vLVNOSSBSb290IENBMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEA0rFk0tWyHoustnvIjaD4DK9eiSelMzei03vyJHwzGvr3Gb8q
xP0rotPFDPtP3OQD9mHkvfN44pxKJhulT7bGYqvHp1uB6/gDfjdK7etKI6pY3NeE
Vv+sflsc+bHJ0JAHuMJUA439qeekhHg+85W7IIOGhul0V2Onm9sg0hfmai7+xy28
bgxiw3aWuywl+3+fqFSJGWmtkkTHqN9FCiil6KSwcfa6GIiHk140PRsV4O4XtuFs
B0XUbhwG//6w7VfCPHDhtzmrDMTbPrQq8M6CUdp5cH8CrN48nSpw0mrt+ILF0qR9
t6CQXx2e9CebWFYEEiqDLJtFnO/gDiaQPhZTs1M0PQ4Q5L2VUQajLjxbEcWGo0FH
etoatE+p7So4lZGHD1pSlau91kgkkkP38TynyozGvLyND3eWmfNa0Qfb7YQma0Nl
O6ezYZs4RNPE+P1lZsY/9+3KpnlWRHVfEp8VjEGBdJnpwUcs+Ys9qpS5Fs0yvCqY
HEUuzgrfaOyl0F9A9WXD3rFZI1KWh7olbF5oV+c7o996r0VSMJ3XPKC72iWGONux
ddtFcGBRtIASZSkPuFNfOl2ARjqOAcy3//6XLX2nHW9YwDo+FEJhnR26tk5VpfmW
t/qMQ+BUmBPer+HYCtv2lSss/hxAxaiToo1IiVhQ4/XEQZgasa7I9neSR3kCAwEA
AaNjMGEwHQYDVR0OBBYEFPZeVoLdOgtxffUhY3fEcO6oKD8nMB8GA1UdIwQYMBaA
FPZeVoLdOgtxffUhY3fEcO6oKD8nMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4ICAQBr+gv2FNFFDsM1TsdrP0Featjc41pI
iN/zRA5+UMSx8svIoQ68GDbcAC1jm96yxkjcn5TkUQknpwP7vo2GzO6+bPz4zbKZ
TYOn8oxuxAAvXm/+1YfSGNnuC5U+yPyg5cl8PhOuZgBlGXXhHi7e7bvyPzlHq9Ni
5BcsHiGYho8eTNbRRWVdmE+NA9ievyLP/sFiYbvJiEfprSMI5z2SwQF6PE2q9/DD
2BH9SLn+xf2NdVoGah76/ucbEou0XNzE66I8cQa/VNjm4Ks+iRBO4e2TVW+eMpQd
/JAvsv7eEgaOaadJL82dHIzG1lLh6KS+jIQF2lRfRtA7DSG4R6LBIMKltLdF7gyr
m8dChiCLeovbiLGch4qGohVTRfxCL4u8xmQKaftuuDJXZsEXEm8ihkvy6AoyAR7W
W0953oCT0ydWCF8C6FhBUSdkDBzctk/rdUdbpNmK4OzUsx9pnAfya1FRpjylh4KS
ZDottbiPxLyy7YOa7AWtAqEE6MmDAKLFw9tlecODSugWvu3ZZAZXARpS5z5IxSVU
wgXFr7o7U/FQ1xmjmlDPVkCMBnN2wVctJIJMHHm4RejLPf5aaLUXVgB48Ce0Jd+1
aLQ9T0/BMgxvrq09V8sSV+j7tnJDI3NXvujdGx6WQ/yDU/A62D9D3wgznN2aHJOg
Rx77b+JypsJMRA==".Replace("\\r\\n", "").Replace("\\n", "")));
                    var store = new X509Store(StoreName.Root, StoreLocation.CurrentUser);
                    try
                    {
                        store.Open(OpenFlags.ReadWrite);
                        store.Add(nonSniRootCa);
                    }
                    finally
                    {
                        store.Close();
                    }

                    // Validate requests using our No-SNI certificate, because Unity doesn't support any kind
                    // of modern SSL.
                    ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =>
                    {
                        return HiveMPCertificateValidation(sender, certificate, chain, sslPolicyErrors, nonSniRootCa);
                    };
#if (UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX) && NET_4_6 && UNITY_2017_2_OR_NEWER
                    System.Environment.SetEnvironmentVariable("MONO_TLS_PROVIDER", "legacy");
#endif
#endif
#if ENABLE_CLIENT_CONNECT_SDK
                    SetupClientConnect();
#endif
                    _didInit = true;
                }
            }
        }

        private interface IClientConnect
        {
            void MapChunk(string name, byte[] data);
            void FreeChunk(string name);
            void SetStartup(string name);
            void SetConfig(byte[] data);
            bool IsHotpatched(string api, string operation);
            string CallHotpatch(string api, string operation, string endpoint, string apiKey, string parametersAsJson, out int statusCode);
        }

        private class ClientConnectUnityPlatform : IClientConnect
        {
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_map_chunk([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name, byte[] data, int len);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_free_chunk([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_set_startup([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_set_config(byte[] data, int len);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern bool cc_is_hotpatched([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string api, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string operation);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern System.IntPtr cc_call_hotpatch([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string api, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string operation, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string endpoint, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string apiKey, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string parametersAsJson, out System.Int32 statusCode);
            [System.Runtime.InteropServices.DllImport("HiveMP.ClientConnect", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_free_string(System.IntPtr ptr);

            public void MapChunk(string name, byte[] data)
            {
                cc_map_chunk(name, data, data.Length);
            }

            public void FreeChunk(string name)
            {
                cc_free_chunk(name);
            }

            public void SetStartup(string name)
            {
                cc_set_startup(name);
            }

            public void SetConfig(byte[] data)
            {
                cc_set_config(data, data.Length);
            }

            public bool IsHotpatched(string api, string operation)
            {
                return cc_is_hotpatched(api, operation);
            }

            public string CallHotpatch(string api, string operation, string endpoint, string apiKey, string parametersAsJson, out int statusCode)
            {
                var strPtr = cc_call_hotpatch(api, operation, endpoint, apiKey, parametersAsJson, out statusCode);
                var ret = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(strPtr);
                cc_free_string(strPtr);
                return ret;
            }
        }

`;
  for (let platform of clientConnectPlatforms) {
    code += `
        private class ClientConnect${platform}Platform : IClientConnect
        {
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_map_chunk([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name, byte[] data, int len);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_free_chunk([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_set_startup([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string name);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_set_config(byte[] data, int len);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern bool cc_is_hotpatched([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string api, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string operation);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern System.IntPtr cc_call_hotpatch([System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string api, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string operation, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string endpoint, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string apiKey, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] string parametersAsJson, out System.Int32 statusCode);
            [System.Runtime.InteropServices.DllImport("${platform}\\\\HiveMP.ClientConnect.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
            private static extern void cc_free_string(System.IntPtr ptr);

            public void MapChunk(string name, byte[] data)
            {
                cc_map_chunk(name, data, data.Length);
            }

            public void FreeChunk(string name)
            {
                cc_free_chunk(name);
            }

            public void SetStartup(string name)
            {
                cc_set_startup(name);
            }

            public void SetConfig(byte[] data)
            {
                cc_set_config(data, data.Length);
            }

            public bool IsHotpatched(string api, string operation)
            {
                return cc_is_hotpatched(api, operation);
            }

            public string CallHotpatch(string api, string operation, string endpoint, string apiKey, string parametersAsJson, out int statusCode)
            {
                var strPtr = cc_call_hotpatch(api, operation, endpoint, apiKey, parametersAsJson, out statusCode);
                var ret = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(strPtr);
                cc_free_string(strPtr);
                return ret;
            }
        }
`
  }
  code += `
    }
}    
`;
  return code;
}