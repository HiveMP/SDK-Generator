export function getPromiseSchedulerSettingsClass(genericNamespace: string, defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

#if UNITY_5 || UNITY_5_3_OR_NEWER
#define IS_UNITY
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
#if IS_UNITY
using UnityEngine;
#endif

namespace ${genericNamespace}
{
    /// <summary>
    /// Configures the scheduler for HiveMP promises.
    /// </summary>
    public class HiveMPPromiseSchedulerSettings
    {
#if !IS_UNITY
        public static Func<object> CoroutineWaitObjectFactory = null;
        public static Action<IEnumerator> ScheduleCoroutine = null;
#endif
    }
}
`;
}

export function getPromiseMainThreadReturnClass(genericNamespace: string, defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

#if UNITY_5 || UNITY_5_3_OR_NEWER
#define IS_UNITY
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
#if IS_UNITY
using UnityEngine;
#endif

namespace ${genericNamespace}
{
    public class HiveMPPromiseMainThreadReturnHandler<T>
    {
        protected Action<T> _resolve;
        protected Action<Exception> _reject;
        protected bool _hasT;
        protected T _t;
        protected Exception _ex;

        public HiveMPPromiseMainThreadReturnHandler(HiveMPPromiseDelegate<T> task, Action<T> resolve, Action<Exception> reject)
        {
            _resolve = resolve;
            _reject = reject;

            StartCoroutine(WaitUntilResult());
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    task((result) =>
                    {
                        _t = result;
                        _hasT = true;
                    }, (ex) =>
                    {
                        _ex = ex;
                    });
                }
                catch (Exception ex)
                {
                    _ex = ex;
                }
            });
        }

        protected static void StartCoroutine(IEnumerator e)
        {
#if IS_UNITY
            HiveMPSDK.GetUnityMonoBehaviour().StartCoroutine(e);
#else
            if (HiveMPPromiseSchedulerSettings.ScheduleCoroutine == null)
            {
                throw new System.InvalidOperationException("Attempted to schedule a coroutine for HiveMP, but HiveMPPromiseSchedulerSettings.ScheduleCoroutine was null!");
            }

            HiveMPPromiseSchedulerSettings.ScheduleCoroutine(e);
#endif
        }

        protected IEnumerator<object> WaitUntilResult()
        {
            do
            {
#if IS_UNITY
                yield return new WaitForFixedUpdate();
#else
                object o;
                if (HiveMPPromiseSchedulerSettings.CoroutineWaitObjectFactory == null)
                {
                    o = new object();
                }
                else
                {
                    o = HiveMPPromiseSchedulerSettings.CoroutineWaitObjectFactory();
                }
                if (o == null)
                {
                    o = new object();
                }
                yield return o;
#endif
            } while (!_hasT && _ex == null);

            if (_hasT)
            {
                _resolve(_t);
            }
            else
            {
                _reject(_ex);
            }
        }
    }
    
    public class HiveMPPromiseMainThreadReturnHandler
    {
        protected Action _resolve;
        protected Action<Exception> _reject;
        protected bool _hasResult;
        protected Exception _ex;

        public HiveMPPromiseMainThreadReturnHandler(HiveMPPromiseDelegate task, Action resolve, Action<Exception> reject)
        {
            _resolve = resolve;
            _reject = reject;

            StartCoroutine(WaitUntilResult());
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    task(() =>
                    {
                        _hasResult = true;
                    }, (ex) =>
                    {
                        _ex = ex;
                    });
                }
                catch (Exception ex)
                {
                    _ex = ex;
                }
            });
        }

        protected static void StartCoroutine(IEnumerator e)
        {
#if IS_UNITY
            HiveMPSDK.GetUnityMonoBehaviour().StartCoroutine(e);
#else
            if (HiveMPPromiseSchedulerSettings.ScheduleCoroutine == null)
            {
                throw new System.InvalidOperationException("Attempted to schedule a coroutine for HiveMP, but HiveMPPromiseSchedulerSettings.ScheduleCoroutine was null!");
            }

            HiveMPPromiseSchedulerSettings.ScheduleCoroutine(e);
#endif
        }

        protected IEnumerator<object> WaitUntilResult()
        {
            do
            {
#if IS_UNITY
                yield return new WaitForFixedUpdate();
#else
                object o;
                if (HiveMPPromiseSchedulerSettings.CoroutineWaitObjectFactory == null)
                {
                    o = new object();
                }
                else
                {
                    o = HiveMPPromiseSchedulerSettings.CoroutineWaitObjectFactory();
                }
                if (o == null)
                {
                    o = new object();
                }
                yield return o;
#endif
            } while (!_hasResult && _ex == null);

            if (_hasResult)
            {
                _resolve();
            }
            else
            {
                _reject(_ex);
            }
        }
    }
}
`;
}

export function getPromiseUnityMonoBehaviourClass(genericNamespace: string, defines: string[]) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

${defines.join("\n")}

#if UNITY_5 || UNITY_5_3_OR_NEWER
#define IS_UNITY
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
#if IS_UNITY
using UnityEngine;
#endif

namespace ${genericNamespace}
{
#if IS_UNITY
    public class HiveMPUnityMonoBehaviour : MonoBehaviour
    {
        public void Start()
        {
            DontDestroyOnLoad(gameObject);
        }

        public void Update()
        {
            ${genericNamespace}.HiveMPSDK.Tick();
        }
    }
#endif
}
`;
}

export function getPromiseClass(genericNamespace: string) {
  return `
//------------------------
// <auto-generated>
//     Generated with HiveMP SDK Generator
// </auto-generated>
//------------------------

using System;
using System.Collections.Generic;

namespace ${genericNamespace}
{
    /// <summary>
    /// A C# promise, which encapsulates asynchronous work to be done and allows it to
    /// be chained with other promises or resolved on a background thread.
    /// </summary>
    public class HiveMPPromise
    {
        private readonly HiveMPPromiseDelegate _handler;
        private List<Action> _then;
        private List<Action<Exception>> _catch;

        /// <summary>
        /// Creates a new C# promise with no result value.
        /// </summary>
        /// <param name="handler">The callback handler to execute with this promise.</param>
        public HiveMPPromise(HiveMPPromiseDelegate handler)
        {
            _handler = handler;
            _then = new List<Action>();
            _catch = new List<Action<Exception>>();
        }

        /// <summary>
        /// The callback handler. This is provided so that a scheduler can execute it
        /// on a background thread when desired by the user.
        /// </summary>
        public HiveMPPromiseDelegate Handler { get { return _handler; } }

        /// <summary>
        /// The resolve method which calls all of the registered "then" chains. This should
        /// only be used inside the scheduler code, and never called directly by the user.
        /// </summary>
        public void Resolve()
        {
            foreach (var then in _then)
            {
                then();
            }
        }

        /// <summary>
        /// The reject method which calls all of the registered "catch" chains. This should
        /// only be used inside the scheduler code, and never called directly by the user.
        /// </summary>
        /// <param name="error">The promise exception.</param>
        public void Reject(Exception error)
        {
            foreach (var @catch in _catch)
            {
                @catch(error);
            }
        }

        /// <summary>
        /// Chains an action to be called when this promise resolves successfully.
        /// </summary>
        /// <param name="next">The action to be called.</param>
        /// <returns>The promise instance.</returns>
        public HiveMPPromise Then(Action next)
        {
            _then.Add(next);
            return this;
        }

        /// <summary>
        /// Chains an action to be called when this promise is rejected with an exception.
        /// </summary>
        /// <param name="error">The action to be called.</param>
        /// <returns>The promise instance.</returns>
        public HiveMPPromise Catch(Action<Exception> error)
        {
            _catch.Add(error);
            return this;
        }
    }
}
`;
}

export function getPromiseGenericClass(genericNamespace: string) {
  return `
using System;
using System.Collections.Generic;

namespace ${genericNamespace}
{
    /// <summary>
    /// A C# promise, which encapsulates asynchronous work to be done and allows it to
    /// be chained with other promises or resolved on a background thread.
    /// </summary>
    /// <typeparam name="T">The return type of the promise.</typeparam>
    public class HiveMPPromise<T>
    {
        private readonly HiveMPPromiseDelegate<T> _handler;
        private List<Action<T>> _then;
        private List<Action<Exception>> _catch;

        /// <summary>
        /// Creates a new C# promise with a return result.
        /// </summary>
        /// <param name="handler">The callback handler to execute with this promise.</param>
        public HiveMPPromise(HiveMPPromiseDelegate<T> handler)
        {
            _handler = handler;
            _then = new List<Action<T>>();
            _catch = new List<Action<Exception>>();
        }

        /// <summary>
        /// The callback handler. This is provided so that a scheduler can execute it
        /// on a background thread when desired by the user.
        /// </summary>
        public HiveMPPromiseDelegate<T> Handler { get { return _handler; } }

        /// <summary>
        /// The resolve method which calls all of the registered "then" chains. This should
        /// only be used inside the scheduler code, and never called directly by the user.
        /// </summary>
        /// <param name="result">The promise result.</param>
        public void Resolve(T result)
        {
            foreach (var then in _then)
            {
                then(result);
            }
        }

        /// <summary>
        /// The reject method which calls all of the registered "catch" chains. This should
        /// only be used inside the scheduler code, and never called directly by the user.
        /// </summary>
        /// <param name="error">The promise exception.</param>
        public void Reject(Exception error)
        {
            foreach (var @catch in _catch)
            {
                @catch(error);
            }
        }

        /// <summary>
        /// Chains an action to be called when this promise resolves successfully.
        /// </summary>
        /// <param name="next">The action to be called.</param>
        /// <returns>The promise instance.</returns>
        public HiveMPPromise<T> Then(Action<T> next)
        {
            _then.Add(next);
            return this;
        }

        /// <summary>
        /// Chains an action to be called when this promise is rejected with an exception.
        /// </summary>
        /// <param name="error">The action to be called.</param>
        /// <returns>The promise instance.</returns>
        public HiveMPPromise<T> Catch(Action<Exception> error)
        {
            _catch.Add(error);
            return this;
        }
    }
}
`;
}

export function getPromiseDelegateClass(genericNamespace: string) {
  return `
using System;

namespace ${genericNamespace}
{
    /// <summary>
    /// A callback to use with <see cref="HiveMPPromise"/>.
    /// </summary>
    /// <param name="resolve">Call this method when the callback is returning normally.</param>
    /// <param name="reject">Call this method when the callback encounters an error.</param>
    public delegate void HiveMPPromiseDelegate(Action resolve, Action<Exception> reject);
}
`;
}

export function getPromiseDelegateGenericClass(genericNamespace: string) {
  return `
using System;

namespace ${genericNamespace}
{
    /// <summary>
    /// A callback to use with <see cref="HiveMPPromise{T}"/>.
    /// </summary>
    /// <typeparam name="T">The return value of the callback.</typeparam>
    /// <param name="resolve">Call this method when the callback is returning a result.</param>
    /// <param name="reject">Call this method when the callback encounters an error.</param>
    public delegate void HiveMPPromiseDelegate<T>(Action<T> resolve, Action<Exception> reject);
}
`;
}

export function getPromiseSchedulerClass(genericNamespace: string) {
  return `
using System;
using System.Threading;

namespace ${genericNamespace}
{
    public class HiveMPPromiseScheduler
    {
        /// <summary>
        /// Executes a promise on a background thread, then executes the registered resolve
        /// and reject handlers on the main thread.
        /// </summary>
        /// <param name="promise">The promise to execute on the background thread.</param>
        public static void ExecuteWithMainThreadCallbacks(HiveMPPromise promise)
        {
            new HiveMPPromiseMainThreadReturnHandler(promise.Handler, promise.Resolve, promise.Reject);
        }

        /// <summary>
        /// Executes a promise on a background thread, then executes the registered resolve
        /// and reject handlers on the main thread.
        /// </summary>
        /// <param name="promise">The promise to execute on the background thread.</param>
        public static void ExecuteWithMainThreadCallbacks<T>(HiveMPPromise<T> promise)
        {
            new HiveMPPromiseMainThreadReturnHandler<T>(promise.Handler, promise.Resolve, promise.Reject);
        }

        /// <summary>
        /// Executes a promise on a background thread, then executes the registered resolve
        /// and reject handlers on a background thread.
        /// </summary>
        /// <param name="promise">The promise to execute on the background thread.</param>
        public static void Execute(HiveMPPromise promise)
        {
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    promise.Handler(promise.Resolve, promise.Reject);
                }
                catch (Exception ex)
                {
                    promise.Reject(ex);
                }
            });
        }

        /// <summary>
        /// Executes a promise on a background thread, then executes the registered resolve
        /// and reject handlers on a background thread.
        /// </summary>
        /// <param name="promise">The promise to execute on the background thread.</param>
        public static void Execute<T>(HiveMPPromise<T> promise)
        {
            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    promise.Handler(promise.Resolve, promise.Reject);
                }
                catch (Exception ex)
                {
                    promise.Reject(ex);
                }
            });
        }
    }
}
`;
}